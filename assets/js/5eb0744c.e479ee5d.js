"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[493],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return p}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=l(n),p=r,f=h["".concat(c,".").concat(p)]||h[p]||d[p]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8080:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={},c="eXternal Data Representation",l={unversionedId:"Architecture/XDR_Intro",id:"Architecture/XDR_Intro",title:"eXternal Data Representation",description:"Introduction",source:"@site/../docs/3-Architecture/2-XDR_Intro.md",sourceDirName:"3-Architecture",slug:"/Architecture/XDR_Intro",permalink:"/docs/docs/Architecture/XDR_Intro",editUrl:"https://github.com/kochavalabs/docs/tree/main/../docs/3-Architecture/2-XDR_Intro.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Deterministic Logic",permalink:"/docs/docs/Architecture/Deterministic_Logic"},next:{title:"Mazzaroth-XDR",permalink:"/docs/docs/Architecture/Mazzaroth-XDR"}},u={},d=[{value:"Introduction",id:"introduction",level:2},{value:"XDR in Mazzaroth",id:"xdr-in-mazzaroth",level:2}],h={toc:d};function p(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"external-data-representation"},"eXternal Data Representation"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"This introduction was taken from ",(0,o.kt)("a",{parentName:"em",href:"https://tools.ietf.org/html/rfc4506#section-1"},"RFC 4506"),"\nwhere the complete definition of the XDR data format can be found.")),(0,o.kt)("p",null,"XDR is a standard for the description and encoding of data.  It is useful for\ntransferring data between different computer architectures, and it has been\nused to communicate data between such diverse machines as the SUN WORKSTATION,\nVAX, IBM-PC, and Cray. XDR fits into the ISO presentation layer and is\nroughly analogous in purpose to X.409, ISO Abstract Syntax Notation.  The major\ndifference between these two is that XDR uses implicit typing, while X.409 uses\nexplicit typing."),(0,o.kt)("p",null,"XDR uses a language to describe data formats.  The language can be used only to\ndescribe data; it is not a programming language.  This language allows one to\ndescribe intricate data formats in a concise manner.  The alternative of using\ngraphical representations (itself an informal language) quickly becomes\nincomprehensible when faced with complexity.  The XDR language itself is\nsimilar to the C language, just as Courier is similar to Mesa. Protocols such\nas ONC RPC (Remote Procedure Call) and the NFS (Network File System) use XDR to\ndescribe the format of their data."),(0,o.kt)("p",null,'The XDR standard makes the following assumption: that bytes (or octets) are\nportable, where a byte is defined as 8 bits of data.  A given hardware device\nshould encode the bytes onto the various media in such a way that other hardware\ndevices may decode the bytes without loss of meaning.  For example, the Ethernet\nstandard suggests that bytes be encoded in "little-endian" style, or least\nsignificant bit first.'),(0,o.kt)("h2",{id:"xdr-in-mazzaroth"},"XDR in Mazzaroth"),(0,o.kt)("p",null,"The data format for a blockchain is very important. A transaction will flow\nthrough different languages and versions of binaries before it is finally\nwritten to the blockchain. Any inconsistency in the data format will invalidate\nthe signature, so it is important that there isn't ambiguity in the data format.\nA simple example of how this could be a problem is what would happen if we had\nchosen to use JSON as our data format. The following code snippet demonstrates\nthe problem in a contrived manner:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const myData = \'{      "my": "data", "is": "ambiguous"}\'\nconst myKey = \'0\'.repeat(64)\nconsole.log(sign(myKey, myData).toString(\'hex\')) // 232e83551456c0bf10ac3ad475e3a32801380f0a24f3a9a366b074a57b3c865192f20fa570de50635d4a86a77c3b467d91b1fe6ad081e3574467300c4f516e0d\nconst interpretedData = JSON.parse(myData)\n// Do some work with the data before passing on to the next program\nconsole.log(interpretedData.is) // ambiguous\n// Re-serialize to send forward\nconst outData = JSON.stringify(interpretedData)\nconsole.log(outData) // {"my":"data","is":"ambiguous"}\n// Uh oh this isn\'t the same anymore, the signature isn\'t valid for my data\n')),(0,o.kt)("p",null,"XDR largely circumvents these ambiguities (union types with default arms being\nan exception that we avoid.) We provide ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kochavalabs/xdr-codegen"},"tooling"),"\nthat facilitates working in either rust, javascript or golang. We use XDR for\nall of our shared data types, including the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kochavalabs/mazzaroth-xdr"},"Mazzaroth-XDR"),"\nwhich defines the core Mazzaroth data structures."))}p.isMDXComponent=!0}}]);