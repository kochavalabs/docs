"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[908],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=c(n),d=o,h=m["".concat(s,".").concat(d)]||m[d]||p[d]||a;return n?r.createElement(h,l(l({ref:t},u),{},{components:n})):r.createElement(h,l({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,l=new Array(a);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,l[1]=i;for(var c=2;c<a;c++)l[c]=n[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6555:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return p}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),l=["components"],i={},s="mazzaroth-rs",c={unversionedId:"Developer_Tools/Mazzaroth_RS",id:"Developer_Tools/Mazzaroth_RS",title:"mazzaroth-rs",description:"CircleCI",source:"@site/../docs/4-Developer_Tools/4-Mazzaroth_RS.md",sourceDirName:"4-Developer_Tools",slug:"/Developer_Tools/Mazzaroth_RS",permalink:"/docs/docs/Developer_Tools/Mazzaroth_RS",editUrl:"https://github.com/kochavalabs/docs/tree/main/../docs/4-Developer_Tools/4-Mazzaroth_RS.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Mazzaroth-js",permalink:"/docs/docs/Developer_Tools/Mazzaroth_JS"},next:{title:"Mazzaroth-XDR",permalink:"/docs/docs/Developer_Tools/Mazzaroth_XDR"}},u={},p=[{value:"Usage",id:"usage",level:2},{value:"Running Tests",id:"running-tests",level:2},{value:"Generating Documentation",id:"generating-documentation",level:2},{value:"License",id:"license",level:2}],m={toc:p};function d(e){var t=e.components,n=(0,o.Z)(e,l);return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"mazzaroth-rs"},"mazzaroth-rs"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://circleci.com/gh/kochavalabs/mazzaroth-rs"},(0,a.kt)("img",{parentName:"a",src:"https://circleci.com/gh/kochavalabs/mazzaroth-rs.svg?style=svg",alt:"CircleCI"}))),(0,a.kt)("p",null,"The Mazzaroth Rust Library is a rust library that includes host bindings\nand everything needed to compile rust contracts to Web Assembly, compatible\nwith the Mazzaroth VM.  Here you will find the necessary abi encoders and\ndecoders used to pass and return arguments to contract functions as well as\nthe external host functions available to use."),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,"The first step to using this library is to include the necessary dependencies.",(0,a.kt)("br",{parentName:"p"}),"\n","The following 3 dependencies should be included in your Cargo.toml:"),(0,a.kt)("p",null,"mazzaroth-rs",(0,a.kt)("br",{parentName:"p"}),"\n","mazzaroth-rs-derive",(0,a.kt)("br",{parentName:"p"}),"\n","mazzaroth-xdr"),(0,a.kt)("p",null,"Every contract will have a similar base layout for the main function and the contract trait definition.\n",(0,a.kt)("inlineCode",{parentName:"p"},"main()")," is used as the entry point and has several important features.  It will instantiate the contract,\ncall a host function to retrieve function input, execute the function, and return a response."),(0,a.kt)("p",null,"Here is a basic Hello World contract example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'// must include the ContractInterface and mazzaroth_abi for compiling the macro\nextern crate mazzaroth_rs;\nextern crate mazzaroth_derive;\nuse mazzaroth_rs::ContractInterface;\nuse mazzaroth_rs_derive::mazzaroth_abi;\n\n// using specific external host modules\nuse mazzaroth_rs::external::{transaction, log};\n\n#[no_mangle]\npub fn main() {\n    // panic hook is set to call the host error log function when a panic occurs\n    std::panic::set_hook(Box::new(mazzaroth_rs::external::errors::hook));\n\n    // Creates a new instance of the ABI generated around the Contract\n    let mut contract = HelloWorld::new(Hello {});\n\n    // Use a host function to get arguments\n    let args = transaction::arguments();\n\n    // Execute calls one of the functions defined in the contract\n    // Input for the function to call and it\'s params comes from the Runtime\n    let response = contract.execute(&args);\n\n    // Provide return value through host call\n    transaction::ret(response);\n}\n\n// mazzaroth_abi used to generate the contract from the trait during compilation\n#[mazzaroth_abi(HelloWorld)]\npub trait HelloWorldContract {\n    // hello() defined as a readonly function\n    #[readonly]\n    fn hello(&mut self) -> u32;\n}\n\n// Struct used to implement the contract trait\npub struct Hello {}\n\n// Actual contract implementation\nimpl HelloWorldContract for Hello {\n    fn hello(&mut self) -> u32 {\n        log("Hello World!".to_string());\n        14\n    }\n}\n')),(0,a.kt)("h2",{id:"running-tests"},"Running Tests"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"cargo test --features host-mock\n")),(0,a.kt)("h2",{id:"generating-documentation"},"Generating Documentation"),(0,a.kt)("p",null,"From the root directory run the command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"cargo doc\n")),(0,a.kt)("p",null,"Optionally provide the --open flag to open the docs in a browser after building them."),(0,a.kt)("p",null,"This will put all generated docs in ",(0,a.kt)("inlineCode",{parentName:"p"},"/target/doc")),(0,a.kt)("h2",{id:"license"},"License"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://choosealicense.com/licenses/mit/"},"MIT")))}d.isMDXComponent=!0}}]);