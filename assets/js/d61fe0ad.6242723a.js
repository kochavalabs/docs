(self.webpackChunk=self.webpackChunk||[]).push([[725],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return h},kt:function(){return p}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,h=c(e,["components","mdxType","originalType","parentName"]),u=l(n),p=r,f=u["".concat(s,".").concat(p)]||u[p]||d[p]||o;return n?a.createElement(f,i(i({ref:t},h),{},{components:n})):a.createElement(f,i({ref:t},h))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6300:function(e,t,n){"use strict";n.d(t,{Z:function(){return f}});var a=n(7462),r=n(3366),o=n(7294),i=n(6010),c=n(2125),s=(n(1793),n(2933)),l=n(9009),h=n(8084);function d(e){var t=(0,h.useAllPluginInstancesData)("docusaurus-plugin-redoc");return e?t[e]:Object.values(t)[0]}var u=["id","example","pointer"],p=function(e){var t=e.id,n=e.example,h=e.pointer,p=(0,r.Z)(e,u),f=d(t),b=(0,l.U)(f),m=b.store,y=b.darkStore,k=b.lightStore;return(0,o.useEffect)((function(){k.menu.dispose(),y.menu.dispose()}),[k,y]),o.createElement(c.ThemeProvider,{theme:m.options.theme},o.createElement("div",{className:(0,i.Z)(["redocusaurus","redocusaurus-schema",n?null:"hide-example"])},o.createElement(s.SchemaDefinition,(0,a.Z)({parser:m.spec.parser,options:m.options,schemaRef:h},p))))};p.defaultProps={example:!1};var f=p},1290:function(e,t,n){"use strict";n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return s},metadata:function(){return h},toc:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=n(6300),c=["components"],s={},l="Blockchain",h={unversionedId:"Architecture/Blockchain",id:"Architecture/Blockchain",title:"Blockchain",description:"Smart Contracts",source:"@site/../docs/3-Architecture/7-Blockchain.md",sourceDirName:"3-Architecture",slug:"/Architecture/Blockchain",permalink:"/docs/docs/Architecture/Blockchain",editUrl:"https://github.com/kochavalabs/docs/tree/main/../docs/3-Architecture/7-Blockchain.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Data Structures",permalink:"/docs/docs/Architecture/Data_Structures"},next:{title:"m8",permalink:"/docs/docs/Developer_Tools/M8"}},d={},u=[{value:"Smart Contracts",id:"smart-contracts",level:2},{value:"Life Cycle",id:"life-cycle",level:3},{value:"Ledger",id:"ledger",level:2},{value:"Blocks",id:"blocks",level:3},{value:"Transactions",id:"transactions",level:3},{value:"Contract",id:"contract",level:4},{value:"Receipts",id:"receipts",level:3},{value:"State Database",id:"state-database",level:2},{value:"Contract State",id:"contract-state",level:3}],p={toc:u};function f(e){var t=e.components,n=(0,r.Z)(e,c);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"blockchain"},"Blockchain"),(0,o.kt)("h2",{id:"smart-contracts"},"Smart Contracts"),(0,o.kt)("p",null,"A Mazzaroth Smart Contract is a WebAssembly binary that defines the functions\nthat may be called by transactions submitted to the channel and how data is\nstored in state for that channel. There are many different ways to write code\nthat can be compiled to Web Assembly. The requirement for it to be considered\na Mazzaroth Smart Contract is that it includes a main function and handles the\ninput object correctly. The way this is done will vary depending on the language\nthat is being compiled to WebAssembly so it would be helpful to use a library\nthat provides these features.\nSee ",(0,o.kt)("a",{parentName:"p",href:"#Writing-a-Smart-Contract"},"below")," for more information about writing contracts."),(0,o.kt)("p",null,"A Channel in Mazzaroth can contain a single contract that may be updated by the\nChannel owner. Once a Smart Contract has been deployed to a channel other users\nmay interact with the channel by submitting transactions to call exported functions\nof the contract."),(0,o.kt)("p",null,"Smart Contracts have access to the Mazzaroth host system interface and can\ndefine how ",(0,o.kt)("a",{parentName:"p",href:"#State-Database"},"State")," gets updated during function execution."),(0,o.kt)("h3",{id:"life-cycle"},"Life Cycle"),(0,o.kt)("p",null,"The basic steps of a Transaction's lifecycle in Mazzaroth are as follows:"),(0,o.kt)("p",null,"A transaction is created by a user and is signed by their account or an authorized\naccount for the sender of the transaction."),(0,o.kt)("p",null,"The transactions are submitted to a Gateway Node in the targeted network using the\n",(0,o.kt)("inlineCode",{parentName:"p"},"transactions")," RPC API endpoint."),(0,o.kt)("p",null,"The Gateway Node performs some basic validation, such as checking that the Transaction\nis properly signed and includes the proper channel ID. If the Validation succeeds\nthe Gateway Node will send the Transaction to a Consensus node in the network and\nreturn the Transaction ID in the submit response."),(0,o.kt)("p",null,"When a Consensus Node receives a Transaction from a Gateway Node it performs similar\nvalidation on the signature and channel ID, then submits the transaction to the Consensus\nprotocol. The participating Consensus nodes use a form of the Practical Byzantine\nFault Tolerance (PBFT) consensus protocol to order the transactions that have been\nsubmitted. Once ordering has finalized each Consensus Node will execute the transaction,\nupdate the ledgers, and gossip the transaction back to Gateway Nodes."),(0,o.kt)("p",null,"Gateway Nodes that receive transactions from Consensus will queue the transactions\nto ensure that they are executed in the correct order. Once they have the next transactions\nto execute they will execute them and update their own ledgers."),(0,o.kt)("p",null,"A user can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"transactions")," API with the Transaction ID to check if\na transaction has been finalized."),(0,o.kt)("h2",{id:"ledger"},"Ledger"),(0,o.kt)("p",null,"The Ledger is a digital record of blocks and transactions that have been accepted\ninto the Blockchain. The Blockchain itself can be thought of as a distributed\nledger. Every node keeps its own copy of the ledger."),(0,o.kt)("h3",{id:"blocks"},"Blocks"),(0,o.kt)("p",null,"See XDR definition ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kochavalabs/mazzaroth-xdr/blob/master/idl/block.x"},"here"),"."),(0,o.kt)("p",null,"A block contains a block header and a list of transactions. Blocks are stored\nin the ledger and are able to be looked up by the block number or by the block\nheader hash. Each block includes the hash of the previous block header, which\nlinks the two and forms the block chain. See below for a complete list of\nfields stored in a Block and Block Header Object along with their description."),(0,o.kt)(i.Z,{pointer:"#/definitions/Block",mdxType:"ApiSchema"}),(0,o.kt)("h3",{id:"transactions"},"Transactions"),(0,o.kt)("p",null,"See XDR definition ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kochavalabs/mazzaroth-xdr/blob/master/idl/transaction.x"},"here"),"."),(0,o.kt)("p",null,"A transaction contains an action, which gets processed by the\nMazzaroth Virtual Machine (RothVM) on a channel. This can do things such as\nUpdate a Contract, Call a Function, or set permissions on an account.\nAfter a write transaction has gone through consensus and\nhas been executed within the RothVM it is added to the ledger. Once a\ntransaction has been added to the ledger it may be retrieved by using the\ntransaction ID which is the unique hash of the Transaction object itself.\nIt must be signed by either the sending account owner or an\nauthorized signer for an account. See below for a list of the fields and\ndescriptions stored in a Transaction Object."),(0,o.kt)(i.Z,{pointer:"#/definitions/Transaction",mdxType:"ApiSchema"}),(0,o.kt)("h4",{id:"contract"},"Contract"),(0,o.kt)("p",null,"Transactions may also be used to update the Contract state of a channel. A\nchannel can only have one contract that defines the functions available. The\ncontract is set by the owner through a Deploy Transaction. See the\n",(0,o.kt)("a",{parentName:"p",href:"#Contract-Object"},"Contract Object")," above for an example of how this field can be\nset on a transaction."),(0,o.kt)("p",null,"Example Deploy Transaction JSON:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-JSON"},'{\n "sender": "3b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29",\n "signature": "41673b6ca7d17463a722ce6c2b9c0e5f68bf6f4d085530476c60341e11eb926305ea9730884a7807faf2484a5e6e8cef566479eea21628fcb3da2f48ab235bf3",\n "data": {\n  "channelID": "0000000000000000000000000000000000000000000000000000000000000000",\n  "nonce": "5304039207213195818",\n  "blockExpirationNumber": "100",\n  "category": {\n   "type": 2,\n   "data": {\n    "version": "0.0.1",\n    "owner": "3b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29",\n    "abi": {\n     "version": "0.8.0",\n     "functions": [],\n    },\n    "contractHash": "6f5a561f67c1e874140ef682914e616a422fd336b67576709738876ca37080d1",\n    "contractBytes": "contract bytes"\n   }\n  }\n }\n}\n')),(0,o.kt)("h3",{id:"receipts"},"Receipts"),(0,o.kt)("p",null,"See XDR definition ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kochavalabs/mazzaroth-xdr/blob/master/idl/receipt.x"},"here"),"."),(0,o.kt)("p",null,"Receipts are the stored results from the execution of a transaction.\nReceipts for every transaction that is accepted by Consensus are stored, along\nwith the transaction itself, in the ledger. Receipts may be looked up by the\nTransaction ID use the Mazzaroth RPC API on a Gateway node."),(0,o.kt)(i.Z,{pointer:"#/definitions/Receipt",mdxType:"ApiSchema"}),(0,o.kt)("h2",{id:"state-database"},"State Database"),(0,o.kt)("p",null,"The Mazzaroth Virtual Machine (RothVM) contains a State Database that stores all\nof the data necessary for the channel. The Database is used to store and access\nobjects for a channel and is backed by a Merkle Tree. The State DB may get updated\nas a result of Transaction execution, such as by updating the Contract store in state\nor by executing a contract function that stores a value. The Merkle root of the\nState DB is stored in block headers when blocks are finalized."),(0,o.kt)("p",null,"There are a number of different items that are stored in the StateDB including\nthe Contract binary and general Contract State."),(0,o.kt)("h3",{id:"contract-state"},"Contract State"),(0,o.kt)("p",null,"The Contract itself is stored in state along with its version number. The\nContract Object fields are defined below. When a Contract is deployed to the\nchannel it no only updates the Virtual Machine to use the new binary, but it also\nupdates state. This is useful as a way to know that nodes have the exact same\ncopy of the contract, because if a different contract was stored in a node's state\nit would have a different state root value. See the ",(0,o.kt)("a",{parentName:"p",href:"#Contract-Object"},"Contract Object"),"\nabove for more information on the fields within the Contract Object."))}f.isMDXComponent=!0},5101:function(){},2116:function(){},3197:function(){}}]);